var relearn_searchindex = [
  {
    "breadcrumb": "APIOps with Insomnia",
    "content": "Insomnia is a collaborative integrated development environment (IDE) designed specifically for modern API workflows. It enables fast, iterative production of well-defined and consumable APIs.\nWith Insomnia, you can design, debug, test, and document your API — all from a single interface. Whether you’re working solo or across a team, Insomnia helps accelerate development while ensuring your APIs are robust and production-ready.\nWhat Insomnia Offers Insomnia provides a user-friendly interface that allows developers to:\nCreate and edit OpenAPI specifications Send requests to REST, SOAP, GraphQL, and gRPC APIs Inspect live responses Write complex test suites for manual or automated testing Work across multiple environments, including local, test, staging, and production Automate workflows with a powerful CLI (Inso CLI) Insomnia Supports 3 Vital Stages of API Development Design\nBuild your API specification with linting and instant feedback. Visual editing of OpenAPI specs via the spec editor. Debug\nSend test requests and inspect responses. Supports REST, SOAP, gRPC, and GraphQL. No need for separate tooling. Test\nWrite test suites based on your collection of requests. Automate those tests in CI/CD pipelines using the Inso CLI. Insomnia Accelerates Deployment Insomnia helps speed up the deployment process by converting OpenAPI specs directly into:\nKubernetes Custom Resource Definitions (CRDs) Kong Gateway declarative configuration files This means your design can go straight from spec to runtime with minimal friction.\nTwo Tools: Desktop App + Inso CLI Insomnia comes in two forms:\nDesktop App: A powerful GUI interface for designing and debugging APIs. Inso CLI: A command-line interface used to automate tasks as part of your CI/CD or APIOps pipeline. In this workshop, we will cover both.\nInstallation Install both tools from your organisation’s software centre or from the official download pages:\nDesktop Inso CLI Getting Started with Insomnia While Insomnia can be used in local or scratchpad mode, we recommend creating an account and logging in to access the full suite of features:\nKey Benefits of Logging In Manage and switch between multiple projects Enable Git Sync for collaborative workflows Secure access with SSO (OIDC/SAML) for enterprise users Gain access to advanced enterprise features Enterprise Features Overview Enterprise customers have access to additional powerful features:\nOrganisations: Group related projects and teams Git Sync: Full version control and team collaboration RBAC: Role-based access control Custom Spectral Linting Mocking (Cloud \u0026 Self-hosted) Secrets Management via: HashiCorp Vault (HCV) AWS Secrets Manager Azure Key Vault GCP Secret Manager Insomnia Layout: IDE Structure When logged in, the left panel shows the organisation you belong to. In this workshop, we will use the Kong CX organisation.\nTo the right, you can switch between the three main views in Insomnia:\nView Purpose Spec Edit and validate your OpenAPI spec Collections Create requests for debugging and testing Tests Build and run test suites against your API Spec Tab Here you can:\nCreate or paste in OpenAPI specifications Use Spectral-based linting to catch errors Customise the ruleset (we’ll cover this in a later module) Collections Tab This is where you:\nCreate requests to test your API endpoints Add scripting logic (pre-request and post-response) Easily work across different environments (e.g., local vs production) Tests Tab Here you:\nBuild reusable test suites based on your collection Write assertions against responses Run tests manually or using the Inso CLI in your CI/CD pipeline Insomnia Environments In Insomnia, environments are a powerful feature designed to make your API workflows more flexible, portable, and manageable.\nRather than hard-coding server addresses, tokens, or API keys into individual requests, Insomnia allows you to define variables once at the environment level and reference them dynamically across your collections, tests, and specs.\nWhy Environments Matter Problem How Environments Solve It Switching between dev, staging, and prod servers is manual and error-prone Quickly swap environments with a dropdown Secrets like tokens or credentials might get copied into requests accidentally Securely store sensitive values separately Collaboration becomes messy when people point to different servers or databases Share consistent environment templates across teams Types of Environments in Insomnia Base Environment: The global environment configuration for a project. Acts as a parent for all other environments. Sub-Environments: Specific environment configurations for different stages (e.g., local-dev, staging, production). These inherit from the Base Environment. Private vs Shared Environments: Shared environments are synced via Git and visible to team members. Private environments (used mainly for local secrets) are local-only and not shared. How Environments Are Used Defining API base URLs (e.g., {{ base_url }}) Setting authentication tokens dynamically Managing different sets of credentials Parameterise things like region, version numbers, customer IDs, or user roles Example of a simple environment:\n{ \"base_url\": \"http://localhost:8081\", \"api_key\": \"super-secret-key\" } And then in your request:\nGET {{ base_url }}/accounts Authorization: Bearer {{ api_key }} Automatic Environment Generation from OpenAPI Specs When you import or build a design document in Insomnia that includes a servers block, Insomnia will automatically generate a collection environment based on the first server URL.\nFor example, from a spec:\nservers: - url: http://localhost:8081 description: Local development server Insomnia creates an environment like:\n{ \"scheme\": \"http\", \"host\": \"localhost:8081\", \"base_path\": \"\" } You can then rename it to something meaningful like local-dev, and clean it up (for example, deleting any unused fields like base_path).\nBest Practice: Always customise and rename your generated environments to match your project structure.\nWorking with Multiple Environments Once you have multiple environments defined (e.g., local-dev, staging, production), you can easily switch between them using the dropdown in the top left of the Insomnia UI.\nThis changes the values dynamically across all requests and tests without you needing to manually edit URLs or tokens.\nSecurity Considerations Sensitive values like API keys, client secrets, or passwords should be placed in private environments or retrieved from external vaults (covered later in the Secrets Management module). Avoid committing sensitive data accidentally by using secret types or local environments. Summary Using environments properly in Insomnia enables:\nFast, reliable switching between different stages of your API Secure management of credentials and configuration Cleaner, reusable requests and test suites Better team collaboration on shared projects Next Module: Begin API Design In the next module, we will create an Insomnia project for the accounts-service of Kong-Bank, then over the next few modules we will create and iterate upon a OpenAPI specification create collections, mocks, custom linting, and test suites within this Git-backed project.\nContinue to: Module 1: Project Setup and Git Integration",
    "description": "Insomnia is a collaborative integrated development environment (IDE) designed specifically for modern API workflows. It enables fast, iterative production of well-defined and consumable APIs.\nWith Insomnia, you can design, debug, test, and document your API — all from a single interface. Whether you’re working solo or across a team, Insomnia helps accelerate development while ensuring your APIs are robust and production-ready.\nWhat Insomnia Offers Insomnia provides a user-friendly interface that allows developers to:",
    "tags": [],
    "title": "00 - Insomnia Overview",
    "uri": "/00-insomnia-overview/index.html"
  },
  {
    "breadcrumb": "APIOps with Insomnia",
    "content": "Welcome to the Insomnia Workshop.\nIn this course, we will work through the design, testing, and automation of an OpenAPI specification using Insomnia and the Inso CLI. All work will be managed via Git from the start, following best practice for collaborative API development.\nThis first module focuses on setting up your project using Git integration with Insomnia v11.\nAbout This Workshop You will be working with a Git-backed API specification project for the kong-bank Accounts API. The template repository for this service is hosted on your organisation’s GitHub Enterprise instance and will be referenced throughout this workshop as:\nhttps://github.com/konghq-cx/accounts-service.git\nNote: https://github.com/konghq-cx is the address for the public version of this repository, if your company uses an enterprise git offering then this address will be updated in the course notes.\nThis repository contains:\nA ready-made implementation of the accounts service, written in Python. A docker-compose.yaml file for launching a local version of the service You will build up a specification and its associated tests for the accounts-service throughout the course.\nBefore You Begin Ensure you have the following installed:\nInsomnia v11 docker and docker-compose Access to your company’s GitHub Enterprise Step 1: Create Your Repository from the Template First, locate the template repository at:\nhttps://github.com/konghq-cx/accounts-service.git\nNote: https://github.com/konghq-cx is the address for the public version of this repository, if your company uses an enterprise git offering then this address will be updated in the course notes.\nCreate your own repository from this template by:\nNavigate to the template repository in your browser Click on “Use this template” or “Generate from template” (the exact wording may vary based on your GitHub Enterprise setup) Name your new repository following the convention of adding your initials to the end: accounts-service-\u003cyour-initials\u003e For example: accounts-service-sb if your initials are SB 4. Complete the repository creation process\nNow clone your new repository locally:\ngit clone https://github.com/konghq-cx/accounts-service-\u003cyour-initials\u003e.git cd accounts-service-\u003cyour-initials\u003e Note: https://github.com/konghq-cx is the address for the public version of this repository, if your company uses an enterprise git offering then this address will be updated in the course notes.\nDocker Compose Configuration Inside this repo, you will find a docker-compose.yaml file. This file can be used to start and stop the accounts-service implementation.\nWhile Kong typically recommends a specification-first approach to API development, the goal of this workshop is to focus on exploring and understanding the features of Insomnia. For that reason, having a working API implementation allows us to more effectively demonstrate those features in action. This docker-compose file exposes a working implementation of the accounts-service locally.\nThe service is started using a Docker Compose file, which looks like the following:\nservices: accounts-service: image: kongcx/accounts-service:latest container_name: accounts ports: - \"8081:8081\" restart: unless-stopped environment: - LOG_LEVEL=info As shown, this configuration is simple — it runs the container image and exposes the service on port 8081.\nPlease start the service locally:\ndocker compose up -d Images are hosted in your internal container registry. If you are properly authenticated, the image should pull successfully.\nStep 2: Open Insomnia and Sign In Open Insomnia v11. Sign in using your company email address. You will be redirected to your company’s IDP for SSO (OIDC). Once authenticated, Insomnia will redirect you back to the application. Step 3: Add a Git-Backed Project Insomnia Git projects require an existing remote repository.\nTo add the accounts-service as a Git-backed project:\nClick the + (plus) button in the Projects panel. Choose “Git-Sync”. Set name for the project e.g. accounts-service-\u003cyour-initials\u003e Click next Select the repository from the dropdown when it appears. If the repository does not appear you may need to authorise Insomnia to you GitHub organisation If this happens you can click on the Can't find a repository? Configure the App link, which will take you off to GitHub to authorise Insomnia You will see a message indicating that no existing Insomnia files were found: This is expected as we have not yet added an Insomnia metadata to this project. We will create these the next few modules as we create our OpenAPI specification, collections and tests.\nHow Insomnia Handles Project Metadata (v11) In Insomnia v11, metadata such as collections, test scripts, environments, and design documents are no longer stored in a separate .insomnia directory.\nInstead:\nAll metadata is embedded directly into your OpenAPI spec file. This simplifies syncing and collaboration using Git. Insomnia recognises the spec via OAS annotations and internal metadata blocks. Step 4: Working with Git in Insomnia With Git Sync configured, Insomnia provides powerful Git integration features directly within the interface. These tools allow teams to collaborate on shared API projects while maintaining clean version control and visibility into changes.\nGit Operations Menu Use the Git Sync menu (found in the left-hand sidebar) to: View commit history Create and switch between branches Pull updates from collaborators Commit and push your own changes Managing Branches Maintaining good Git hygiene is essential when working in a collaborative environment. You should:\nUse feature branches to isolate your work Create pull requests to support code review and approvals From the Git menu, you can:\nCreate new branches locally Switch between local and remote branches Note: Remote branches will only appear after they’ve been pushed or fetched at least once.\nCommitting and Pushing Changes To commit:\nClick the Git dropdown and select Commit Inspect the diffs of any proposed changes Stage any changes you want to commit Enter a meaningful, descriptive commit message To push:\nClick Push in the same Git menu On first push, Insomnia will initialise metadata in the spec file Pulling Changes from Collaborators When teammates push updates to the shared repo, you can stay in sync by:\nOpening the Git Sync menu Selecting Pull This will merge their changes into your local project.\nDisconnect from Git (if needed) To sign out of your Git account:\nGo to Setup Git Sync Open Repository Settings Click Sign Out next to your listed Git account Additional Project Options Rename Your Project (Local Only) Open Project Settings Update the name and click Save Note: The project name is stored locally and is not synced to Git.\nDelete a Git-Backed Project To delete a project from Insomnia:\nFrom the project list, open Project Settings Click Delete Project Confirm deletion Warning: This removes the project from Insomnia but does not delete the remote Git repository.\nPrepare a Feature Branch for Module 02 Now that your Git project is connected, we are ready to set up good Git practices for the rest of the workshop.\nBefore starting Module 02, create a new Git branch that will hold all your work for that module.\nWhy? In real-world API development, it’s common to work in isolated feature branches for each change or improvement. In this workshop, we will mirror that practice:\nEach module will have its own branch This keeps changes clean, isolated, and easy to manage It prepares you for collaborating through pull requests or merge reviews You only need to do this once at the end of Module 01 — each later module will remind you when it’s time to create a new branch.\nSuggested branch name feature/api-spec-design To create it:\nOpen the Git Sync menu Click Branches Type the branch name and click Create Insomnia will automatically switch to the new branch You’ll now be ready to begin designing and testing the API in the next module.\nSummary You have now:\nCloned and run the accounts-service locally Set up a Git-synced project in Insomnia Learned how metadata is stored in Insomnia v11 Explored Git operations and branch management inside the Insomnia app You are now ready to begin working on the API specification itself.\nNext: Module 2: Designing an API Spec",
    "description": "Welcome to the Insomnia Workshop.\nIn this course, we will work through the design, testing, and automation of an OpenAPI specification using Insomnia and the Inso CLI. All work will be managed via Git from the start, following best practice for collaborative API development.\nThis first module focuses on setting up your project using Git integration with Insomnia v11.\nAbout This Workshop You will be working with a Git-backed API specification project for the kong-bank Accounts API. The template repository for this service is hosted on your organisation’s GitHub Enterprise instance and will be referenced throughout this workshop as:",
    "tags": [],
    "title": "01 - Project Setup and Git Integration",
    "uri": "/01-project-setup-and-git-integration/index.html"
  },
  {
    "breadcrumb": "APIOps with Insomnia",
    "content": "In this module, we will design and build a structured OpenAPI specification for the Accounts API, using Insomnia’s built-in Git integration and linting features.\nBy the end of this module, you’ll have:\nCreated a Git-tracked design document Defined a valid and useful OpenAPI specification Built endpoints with proper schemas, examples, and metadata Practiced clean Git commit habits Prepared the foundation for generating collections and creating tests Important: We will commit and push changes at key points, following best practice.\nStep 1: Create a Feature Branch in Insomnia In the previous chapter you should have created the feature/api-spec-design branch, if you did not or are coming to this chapter directly then please create the feature branch now and switch to using it.\nOpen your accounts-service project in Insomnia. In the lower left Git panel, click on the branch name. Create a new branch named: feature/api-spec-design Click Create to switch to it. Working on feature branches makes collaboration easier and prevents conflicts.\nStep 2: Create a New API Specification Let’s create a new OpenAPI design document inside the Git project.\nClick the + Create button and choose Design Document. Set: Name: accounts-service Location: api/accounts-service.yaml Click Create Document. You’ll now have an empty spec file, fully tracked in Git. Commit and Push Your Changes Use the Insomnia Git commit menu:\nClick on the Git dropdown in the left sidebar. Select “Commit”. Inspect the changes. If happy, stage the changes. Enter a meaningful commit message: chore: create initial OpenAPI specification document Click Commit. Click Push to update your remote repository. Step 3: Add a Minimal Valid OpenAPI Structure Let’s start with the simplest valid OpenAPI structure.\nPaste this into your design document:\nopenapi: 3.0.3 info: title: Accounts API version: 1.0.0 paths: {} You will immediately see linting feedback at the bottom from Spectral.\nMissing description Missing contact Missing servers In order to fix these here’s what to add and why:\nIssue Fix Why It Matters info.description Add a description to the info block Gives consumers an overview of what the API does and its intended use case info.contact.name Add the maintainer or team name under info.contact.name Makes it clear who to reach out to for support, clarification, or ownership info.contact.email Add an email address under info.contact.email Provides a direct contact point for API consumers or stakeholders servers Define a servers block at the root level Provides users and tools with the base URLs for different environments (e.g., local, test, production) Step 4: Update the Info Section Update the info section and add supporting metadata to fix the linting errors:\nopenapi: 3.0.3 info: title: Accounts API version: 1.0.0 description: This API manages account information and balances. contact: email: stephen.brown@konghq.com servers: - url: http://localhost:8081 description: Local development server paths: {} Step 5: Add the /accounts Endpoint Now we define the POST /accounts operation to create new accounts.\nReplace the paths section with this:\npaths: /accounts: post: summary: Create account responses: '201': description: Account created You will notice that this new endpoint will trigger linter warnings\nWhat’s Missing? While this minimal spec is valid YAML, it will:\nTrigger Spectral linter warnings Fail to generate a usable request body in Insomnia Be incomplete for testing and mocking Missing Element Why It Matters description Without it, documentation lacks detail operationId Required by tools to uniquely identify the operation tag Used by Insomnia to group requests global tag Define the tag at the top level, Ensures documentation tools can display it properly requestBody Needed to define the payload of the request components/schemas Centralises definitions for validation and reuse To correct these issues lets replace the paths section with a more complete example\npaths: /accounts: post: tags: - accounts summary: Create account description: Creates a new account with an initial balance. The account ID is automatically generated. operationId: createAccount requestBody: description: Details of the new account required: true content: application/json: schema: $ref: '#/components/schemas/CreateAccountRequest' examples: savings_account: summary: Savings account example value: type: savings initial_balance: 5000 responses: '201': description: Account created successfully content: application/json: schema: $ref: '#/components/schemas/Account' examples: created_account: summary: Created account value: account_id: \"123e4567-e89b-12d3-a456-426614174000\" type: savings balance: 5000 Also create the components section:\ncomponents: schemas: CreateAccountRequest: type: object required: - type - initial_balance properties: type: type: string description: Type of account (e.g. checking, savings) initial_balance: type: number format: double description: Initial deposit amount Account: type: object properties: account_id: type: string format: uuid type: type: string balance: type: number Create a global tag section and add the accounts tag:\ntags: - name: accounts description: Accounts endpoints Reflection Why does the completeness of these sections matter?\nIncomplete or missing responses would lead to:\nNo machine-readable response format Can’t validate tests Can’t generate mocks Schema definitions enable:\nRequest and mock generation in Insomnia Linting and validation against expected types SDK and client generation using tools like OpenAPI Generator Better documentation previews Without them, we would have:\nProblem Improvement Unclear structure Enables mocks and validation No reuse Centralised schema management No examples Improves docs and auto-generated requests which aids better test coverage Commit and Push Your Changes for the New Endpoints This is where OpenAPI becomes a contract between teams and systems, so this seems like a good point to commit our changes. Use the Insomnia Git commit menu:\nClick on the Git dropdown in the left sidebar. Select “Commit”. Inspect the changes. If happy, stage the changes. Enter a meaningful commit message: feat: add /accounts endpoint and associated schemas Click Commit. Click Push to update your remote repository. Now that we’ve constructed basic endpoint in our specification and explored the importance of a complete, linted API design, we are ready to import a fully completed specification for the accounts-service.\nStep 6: Paste the Completed Specification Now, paste the full final spec to finish Module 2 cleanly.\nopenapi: 3.0.3 info: title: Accounts API version: 1.0.0 description: This API manages account information and balances. contact: email: stephen.brown@konghq.com servers: - url: http://localhost:8081 description: Local development server tags: - name: accounts description: Operations related to account management (retrieval and balance updates) - name: health description: Health check endpoints for monitoring service status paths: /health: get: tags: - health operationId: healthCheck summary: Health check endpoint description: Returns the API's health status responses: '200': description: API is healthy content: application/json: schema: type: string examples: success: summary: Healthy response value: \"Accounts API is running\" head: tags: - health operationId: healthCheckHead summary: Health check endpoint (HEAD) description: Returns the API's health status without body responses: '200': description: API is healthy /accounts: get: tags: - accounts operationId: listAccounts summary: List all accounts description: Returns a list of all accounts with basic details. responses: '200': description: A list of accounts was successfully retrieved content: application/json: schema: type: array items: $ref: '#/components/schemas/Account' examples: multiple_accounts: summary: Multiple accounts example value: - account_id: \"123e4567-e89b-12d3-a456-426614174000\" type: \"checking\" balance: 1500.00 - account_id: \"987fcdeb-51a2-43e7-89bc-765432198765\" type: \"savings\" balance: 5000.00 '500': description: Failed to retrieve accounts due to internal server error content: application/json: schema: $ref: '#/components/schemas/ErrorResponse' examples: lock_error: summary: Database lock error value: error_code: \"INTERNAL_ERROR\" message: \"Lock error: failed to acquire lock while listing accounts\" post: tags: - accounts operationId: createAccount summary: Create a new account description: Creates a new account with an initial balance. The account ID is automatically generated. requestBody: description: Details for the new account including type and initial balance. The account ID will be automatically generated. required: true content: application/json: schema: $ref: '#/components/schemas/CreateAccountRequest' examples: checking_account: summary: Create checking account value: type: \"checking\" initial_balance: 1000.00 savings_account: summary: Create savings account value: type: \"savings\" initial_balance: 5000.00 responses: '201': description: Account created successfully content: application/json: schema: $ref: '#/components/schemas/Account' examples: new_account: summary: Newly created account value: account_id: \"123e4567-e89b-12d3-a456-426614174000\" type: \"checking\" balance: 1000.00 '400': description: Failed to create account due to invalid input content: application/json: schema: $ref: '#/components/schemas/ErrorResponse' examples: invalid_balance: summary: Invalid initial balance value: error_code: \"INVALID_INPUT\" message: \"Failed to create account: Initial balance must be non-negative\" '500': description: Failed to create account due to internal server error content: application/json: schema: $ref: '#/components/schemas/ErrorResponse' examples: creation_error: summary: Account creation failed value: error_code: \"INTERNAL_ERROR\" message: \"Failed to create account: Internal server error occurred\" /accounts/{accountId}: get: tags: - accounts operationId: getAccountById summary: Retrieve a single account description: Returns details for the specified account including current balance. parameters: - name: accountId in: path required: true description: The UUID of the account to retrieve schema: type: string format: uuid example: \"123e4567-e89b-12d3-a456-426614174000\" responses: '200': description: Account details retrieved successfully content: application/json: schema: $ref: '#/components/schemas/Account' examples: checking_account: summary: Example checking account value: account_id: \"123e4567-e89b-12d3-a456-426614174000\" type: \"checking\" balance: 1500.00 '404': description: Account lookup failed - specified account ID does not exist content: application/json: schema: $ref: '#/components/schemas/ErrorResponse' examples: not_found: summary: Account not found error value: error_code: \"NOT_FOUND\" message: \"Failed to retrieve account: ID 123e4567-e89b-12d3-a456-426614174000 not found\" '500': description: Failed to retrieve account details due to internal server error content: application/json: schema: $ref: '#/components/schemas/ErrorResponse' examples: server_error: summary: Internal server error value: error_code: \"INTERNAL_ERROR\" message: \"Failed to retrieve account: Internal server error occurred\" /accounts/{accountId}/debit: post: tags: - accounts operationId: debitAccount summary: Debit an account description: Decreases the account's balance by the specified amount. parameters: - name: accountId in: path required: true description: The UUID of the account to debit schema: type: string format: uuid example: \"123e4567-e89b-12d3-a456-426614174000\" requestBody: description: Specifies the amount to debit from the account balance. required: true content: application/json: schema: $ref: '#/components/schemas/UpdateBalanceRequest' examples: small_debit: summary: Small debit amount value: amount: 100.00 large_debit: summary: Large debit amount value: amount: 1000.00 responses: '200': description: Account debited successfully content: application/json: schema: $ref: '#/components/schemas/Account' examples: successful_debit: summary: Account after successful debit value: account_id: \"123e4567-e89b-12d3-a456-426614174000\" type: \"checking\" balance: 900.00 '400': description: Debit operation failed due to insufficient funds or invalid amount content: application/json: schema: $ref: '#/components/schemas/ErrorResponse' examples: insufficient_funds: summary: Insufficient funds error value: error_code: \"INSUFFICIENT_FUNDS\" message: \"Failed to debit account: Insufficient funds - balance is 900.00, attempted to debit 1000.00\" '404': description: Debit operation failed - account not found content: application/json: schema: $ref: '#/components/schemas/ErrorResponse' examples: not_found: summary: Account not found value: error_code: \"NOT_FOUND\" message: \"Failed to debit account: Account does not exist\" '500': description: Failed to process debit operation due to internal server error content: application/json: schema: $ref: '#/components/schemas/ErrorResponse' examples: server_error: summary: Internal error value: error_code: \"INTERNAL_ERROR\" message: \"Failed to debit account: Internal server error occurred\" /accounts/{accountId}/credit: post: tags: - accounts operationId: creditAccount summary: Credit an account description: Increases the account's balance by the specified amount. parameters: - name: accountId in: path required: true description: The UUID of the account to credit schema: type: string format: uuid example: \"123e4567-e89b-12d3-a456-426614174000\" requestBody: description: Specifies the amount to credit to the account balance. required: true content: application/json: schema: $ref: '#/components/schemas/UpdateBalanceRequest' examples: small_credit: summary: Small credit amount value: amount: 500.00 large_credit: summary: Large credit amount value: amount: 5000.00 responses: '200': description: Account credited successfully content: application/json: schema: $ref: '#/components/schemas/Account' examples: successful_credit: summary: Account after successful credit value: account_id: \"123e4567-e89b-12d3-a456-426614174000\" type: \"checking\" balance: 2000.00 '400': description: Credit operation failed due to invalid amount content: application/json: schema: $ref: '#/components/schemas/ErrorResponse' examples: invalid_amount: summary: Invalid amount error value: error_code: \"INVALID_INPUT\" message: \"Failed to credit account: Amount must be positive\" '404': description: Credit operation failed - account not found content: application/json: schema: $ref: '#/components/schemas/ErrorResponse' examples: not_found: summary: Account not found value: error_code: \"NOT_FOUND\" message: \"Failed to credit account: Account does not exist\" '500': description: Failed to process credit operation due to internal server error content: application/json: schema: $ref: '#/components/schemas/ErrorResponse' examples: server_error: summary: Internal error value: error_code: \"INTERNAL_ERROR\" message: \"Failed to credit account: Internal server error occurred\" components: schemas: Account: type: object description: Represents a bank account with its core details including ID, type, and current balance. example: account_id: \"123e4567-e89b-12d3-a456-426614174000\" type: \"checking\" balance: 1500.00 properties: account_id: type: string format: uuid description: Unique identifier for the account (UUID v4) example: \"123e4567-e89b-12d3-a456-426614174000\" type: type: string description: The type of the account (e.g., checking, savings) example: \"checking\" balance: type: number format: double description: The current balance of the account in the account's currency example: 1500.00 CreateAccountRequest: type: object description: Request payload for creating a new account. example: type: \"savings\" initial_balance: 5000.00 required: - type - initial_balance properties: type: type: string description: The type of account to create (e.g., checking, savings) example: \"savings\" initial_balance: type: number format: double description: The initial balance to fund the account with example: 5000.00 UpdateBalanceRequest: type: object description: Request payload for updating an account's balance via credit or debit operations. example: amount: 100.00 required: - amount properties: amount: type: number format: double description: The amount to credit or debit from the account example: 100.00 ErrorResponse: type: object description: Standard error response structure for all error cases. example: error_code: \"NOT_FOUND\" message: \"The requested account does not exist.\" required: - error_code - message properties: error_code: type: string description: A standardized error code identifying the type of error example: \"NOT_FOUND\" enum: - INTERNAL_ERROR - NOT_FOUND - INSUFFICIENT_FUNDS - INVALID_INPUT message: type: string description: A human-readable description of the error example: \"The requested account does not exist.\" This ensures your design document is complete, Spectral-compliant, and production-ready.\nEndpoint Overview Here is what each endpoint in the spec is responsible for:\nEndpoint Method Purpose /health GET Returns basic availability and health of the service /health HEAD Same as GET but with no response body /accounts GET Lists all registered accounts /accounts POST Creates a new account with an initial balance /accounts/{accountId} GET Fetches full account details by ID /accounts/{accountId}/debit POST Deducts funds from the specified account /accounts/{accountId}/credit POST Adds funds to the specified account All endpoints are fully documented with:\nsummary, description, operationId, and tags Schemas referenced using $ref to reduce duplication Structured error handling for 4xx and 5xx cases Inline and reusable examples for request and response content Final Commit and Push Use the Insomnia Git commit menu:\nClick on the Git dropdown in the left sidebar. Select “Commit”. Inspect the changes. If happy, stage the changes. Enter a meaningful commit message: chore: paste completed Accounts API specification Click Commit. Click Push to update your remote repository. After reviewing your changes, create a pull request from your feature branch into main. Once approved, merge your branch to keep the main branch up-to-date with your completed work.\nSummary You have now:\nCreated a Git-backed OpenAPI spec in Insomnia Built the /accounts endpoint with proper structure Resolved all linter warnings Committed your changes at logical milestones You are ready to move on!\nNext: In Module 3: Collections, we’ll use this complete specification to generate a request collection.",
    "description": "In this module, we will design and build a structured OpenAPI specification for the Accounts API, using Insomnia’s built-in Git integration and linting features.\nBy the end of this module, you’ll have:\nCreated a Git-tracked design document Defined a valid and useful OpenAPI specification Built endpoints with proper schemas, examples, and metadata Practiced clean Git commit habits Prepared the foundation for generating collections and creating tests Important: We will commit and push changes at key points, following best practice.",
    "tags": [],
    "title": "02 - Building the API Specification",
    "uri": "/02-designing-an-api-specification/index.html"
  },
  {
    "breadcrumb": "APIOps with Insomnia",
    "content": "Now that we have built up our API specification and committed our work, it’s time to move into the Collections phase of the Insomnia workflow.\nIn this module, you will:\nGenerate a full request collection Understand how a complete specification improves collection generation Add basic scripting to streamline account management Commit your work and merge it back to main Prerequisites If you are starting the course from this module and have not completed the previous steps, you can import the Insomnia metadata to bring you up to date.\nClone the insomnia-workshop-exports repository:\ngit clone https://github.com/KongHQ-CX/insomnia-workshop-exports.git Note: https://github.com/konghq-cx is the address for the public version of this repository, if your company uses an enterprise git offering then this address will be updated in the course notes.\nThe structure of the repository is:\ninsomnia-workshop-exports |── accounts-service │ ├── module-02 │ │ └── api-spec │ │ └── module-2-end-state.yaml │ ├── module-03 │ ├── module-04 │ │ └── api-spec │ │ └── module-04-end-state.yaml │ ├── module-05 │ │ └── api-spec │ │ └── module-05-end-state.yaml │ ├── module-06 │ │ └── api-spec │ │ └── module-06-end-state.yaml │ ├── module-07 │ │ ├── api-spec │ │ │ └── module-07-end-state.yaml │ │ └── mock-spec │ │ └── module-07-mock-end-state.yaml ├── README.md └── transactions-service ├── module-07 │ ├── api-spec │ │ └── module-07-end-state.yaml │ └── mock-spec │ └── module-07-mock-end-state.yaml └── module-08 └── api-spec └── module-08-end-state.yaml Import the correct “end state” YAML file for the previous module.\nExample: If starting Module 3, import accounts-service/module-02/api-spec/module-2-end-state.yaml into Insomnia. Note: Some modules also include mock metadata. In those cases, import both the api-spec and mock-spec files.\nThis ensures you are starting the module with the correct project state.\nIntroduction to Scripting in Insomnia In this module, we will explore generating request collections and custom scripting in Insomnia. By now, your OpenAPI specification file fully formed and we are ready to generate our requests and utilise Insomnia scripting if required.\nInsomnia supports pre-request and after-response scripting — lightweight JavaScript snippets that run either before a request is sent or after the response is received. These scripts are incredibly useful for preparing data, chaining requests, validating responses, or working with environment variables.\nStep 1: Create a Feature Branch Before we begin working with scripts, let’s create a feature branch to manage these changes:\nIn Insomnia, click on the branch name in the Git panel (lower left corner) Create a new branch named: feature/api-collections-and-scripting Click “Create” to switch to the new branch. This branch will contain all of our collection requests \u0026 scripting additions, keeping them isolated until we’re ready to share with the team.\nStep 2: Generate a Request Collection Now generate the request collection based on your final spec.\nIn the sidebar under Spec, click the gear icon next to the words Spec and Preview. Select Generate Collection. This will: Create structured requests for each endpoint Apply example request bodies and parameters Group requests by tag (e.g., health, accounts) Attach appropriate validation schemas Note: This demonstrates the value of a complete specification — better examples, validations, and structure are automatically included.\nFrom the collections screen we should also update our environment. To do this:\nClick on the Base Environment on the top right-hand side of the Collections screen Then select the edit symbol Once in the environment editing window, make sure your Base Environment: base_url variable looks like this: \"{{ _.scheme }}://{{ _.host }}\" And your auto generated OpenAPI env localhost:8081 environment variables look like this: { \"scheme\": \"http\", \"host\": \"localhost:8081\" } When leaving the environment editor window make sure the OpenAPI env localhost:8081 environment is selected\nStep 3: Understanding Pre- and After-Response Scripts Pre-request scripts run before your request is sent. Common use cases include:\nSetting environment variables Authenticating with tokens Creating prerequisite data (e.g., a bank account before making a deposit) Insomnia Docs: Pre-request scripting\nAfter-response scripts run after the response is received. They’re ideal for:\nExtracting data from the response and storing it for later use Viewing or logging response data Simple validation and verification tasks Insomnia Docs: After-response scripting\nStep 4: Add After-Response Script to Store accountId In the “Create a new account” request:\nSelect the request. Go to the Scripts tab. Add an After-Response Script: // Extract account_id from the response and store it in the environment let data = insomnia.response.json(); insomnia.environment.set(\"accountId\", data.account_id); This script will automatically save the accountId of a newly created account, making follow-up actions much easier.\nExample Response { \"account_id\": \"88c09a4f-bcab-450f-a86f-d4c074f2fab9\", \"type\": \"savings\", \"balance\": 5000 } Optional Quick Validation Example console.log(`Response status: ${insomnia.response.code}`); if (insomnia.response.code !== 201) { console.log(\"Warning: Unexpected status code\"); } While useful during development, for production-grade testing we recommend using proper Test Suites (covered in Module 4).\nPlease run the request now by clicking the send button to validate it is working.\nYou can also validate the accountId environment variable has been set by clicking on the OpenAPI env localhost:8081 environment and selecting the edit icon.\nStep 5: Add Pre-Request Script to Auto-Create an Account if Needed Several requests assume the presence of a valid accountId:\nCredit an account Debit an account Retrieve a single account To automate this:\nAdd a Pre-Request Script for each of these requests:\nif (!insomnia.environment.get(\"accountId\")) { const host = insomnia.environment.get(\"host\"); const scheme = insomnia.environment.get(\"scheme\"); const baseUrl = `${scheme}://${host}`; const createAccountRequest = { url: `${baseUrl}/accounts`, method: 'POST', headers: { 'Content-Type': 'application/json', }, body: { mode: 'raw', raw: JSON.stringify({ type: 'savings', initial_balance: 5000.00, }), }, }; const response = await new Promise((resolve, reject) =\u003e { insomnia.sendRequest(createAccountRequest, (err, resp) =\u003e { if (err != null) reject(err); else resolve(resp); }); }); if (response.code !== 201) { throw new Error(`Account creation failed. Status code: ${response.code}`); } const responseBody = JSON.parse(response.body.toString()); insomnia.environment.set('accountId', responseBody.account_id); } This ensures your tests are reliable and do not depend on manual setup.\nDescription of the Insomnia Pre-request Script This pre-request script dynamically manages the creation of an accountId if it does not already exist in the Insomnia environment. Here is a detailed breakdown of its actions:\nCheck for Existing accountId:\nThe script first checks whether the accountId environment variable is already set. Retrieve Environment Variables:\nIf accountId is not set, it retrieves the host and scheme environment variables. It constructs the baseUrl by combining scheme and host. Prepare the Account Creation Request:\nIt defines a createAccountRequest object configured to: Use the POST method. Target the /accounts endpoint at the constructed baseUrl. Set the Content-Type header to application/json. Send a JSON payload specifying the creation of a savings account with an initial balance of 5000.00. Send the Account Creation Request:\nIt uses insomnia.sendRequest within a Promise to handle asynchronous execution. If the request encounters an error, it is rejected. Otherwise, the response is resolved. Handle the Response:\nThe script checks if the HTTP status code of the response is 201 (Created). If the status code is not 201, it throws an error indicating account creation failure. Extract and Store the accountId:\nIt parses the response body to extract the account_id. It then sets the accountId in the environment variables for subsequent use. Purpose This script ensures that each request requiring an accountId has one readily available, avoiding manual setup or prior dependency on external processes. It dynamically manages prerequisites, improving automation and reducing potential human error during testing or development workflows.\nRun the Requests Once you have added the pre-request scripts to the Credit an account, Debit an account and the Retrieve a single account requests, execute each request by hitting the Send button for each one.\nCredit an account Response Example:\n{ \"account_id\": \"88c09a4f-bcab-450f-a86f-d4c074f2fab9\", \"type\": \"savings\", \"balance\": 5100 } Note the increased balance to 5100\nDebit an account Response Example\n{ \"account_id\": \"88c09a4f-bcab-450f-a86f-d4c074f2fab9\", \"type\": \"savings\", \"balance\": 5000 } Note the decreased balance back to 5000\nRetrieve a single account Response Example\n{ \"account_id\": \"88c09a4f-bcab-450f-a86f-d4c074f2fab9\", \"type\": \"savings\", \"balance\": 5000 } Note the expected balance is 5000\nStep 6: Commit and Push Your Changes Use the Insomnia Git commit menu:\nClick on the Git dropdown in the left sidebar. Select “Commit”. Inspect the changes. If happy, stage the changes. Enter a meaningful commit message: feat: generate collection and add scripting for automatic account management Click Commit. Click Push to update your remote repository. Step 7: Raise a Pull Request After committing and pushing:\nCreate a pull request from your feature/api-collections-and-scripting branch into main. Once reviewed, merge your branch to keep the main branch up-to-date with your completed work. Summary You have now:\nGenerated a complete and structured collection Learned how and when to use pre-request and after-response scripting Added scripts to automate account creation and ID management Committed and merged your changes back into main Next: In Module 4 - Testing, we’ll focus on writing structured, reusable test suites for our API!",
    "description": "Now that we have built up our API specification and committed our work, it’s time to move into the Collections phase of the Insomnia workflow.\nIn this module, you will:\nGenerate a full request collection Understand how a complete specification improves collection generation Add basic scripting to streamline account management Commit your work and merge it back to main Prerequisites If you are starting the course from this module and have not completed the previous steps, you can import the Insomnia metadata to bring you up to date.",
    "tags": [],
    "title": "03 - Collections and Scripting",
    "uri": "/03-collections/index.html"
  },
  {
    "breadcrumb": "APIOps with Insomnia",
    "content": "In this module, we move beyond scripting and focus on structured, reusable Test Suites in Insomnia, while also extending our specification with a new DELETE operation.\nWith your API specification complete and your collections generated, it’s time to ensure everything works reliably, not just manually, but automatically.\nIn this module, you will:\nUnderstand how Test Suites improve API quality Create automated tests linked to your requests Extend the API by adding a DELETE operation Practice versioning and proper Git commit hygiene Commit and push your testing and spec changes Prerequisites If you are starting the course from this module and have not completed the previous steps, you can import the Insomnia metadata to bring you up to date.\nClone the insomnia-workshop-exports repository:\ngit clone https://your-github-enterprise-url/konghq-cx/insomnia-workshop-exports.git Or, internally inside Kong:\ngit clone https://github.com/KongHQ-CX/insomnia-workshop-exports.git Locate and import the correct “end state” YAML file from the previous module.\nFor example, for starting Module 4, import accounts-service/module-03/api-spec/module-03-end-state.yaml. Note: Some modules include both api-spec and mock-spec. Always import both if available.\nThis ensures you are starting the module with the correct project state.\nStep 1: Create a Feature Branch Before we start creating tests and making spec changes:\nIn Insomnia, click on the branch name in the Git panel. Create a new branch named: feature/add-test-suites-and-delete-endpoint Click Create to switch to the new branch. Step 2: Create a Test Suite In the Tests tab, click New test suite. Name it: Accounts API Test Suite This will serve as the container for all your tests.\nStep 3: Write Tests for Core API Endpoints We’ll now create basic functional tests for key endpoints.\nClick the New test button to add each test case\nTest: Create New Account Assign to: Create a new account request Test script: const response = await insomnia.send(); expect(response.status).to.equal(201); const account = JSON.parse(response.data); expect(account).to.have.property('account_id').that.is.a('string'); expect(account).to.have.property('type').that.is.a('string'); expect(account).to.have.property('balance').that.is.a('number'); Description of the Insomnia Test This Insomnia test script performs the following actions:\nSend the Request:\nIt sends the current request and waits for the response. Verify the HTTP Status Code:\nIt asserts that the response status code is 201, indicating successful resource creation. Parse and Validate the Response Body:\nIt parses the response body from JSON format. It asserts that the parsed object includes the following properties: account_id, which must be a string. type, which must be a string. balance, which must be a number. This ensures that the API response has the expected structure and data types after creating a new account.\nTest: List All Accounts Assign to: List all accounts request Test script: const response = await insomnia.send(); expect(response.status).to.equal(200); const accounts = JSON.parse(response.data); expect(accounts).to.be.an('array'); if (accounts.length \u003e 0) { const account = accounts[0]; expect(account).to.have.property('account_id'); } Description of the List All Accounts Insomnia Test This Insomnia test script performs the following actions:\nSend the Request:\nIt sends the current request and waits for the response. Verify the HTTP Status Code:\nIt asserts that the response status code is 200, indicating a successful retrieval. Parse and Validate the Response Body:\nIt parses the response body from JSON format. It asserts that the parsed response is an array. If the array is not empty, it checks that the first object in the array has an account_id property. This ensures that the API correctly returns a list of accounts and that each account object contains the expected account_id field.\nTest: Health Check Assign to: Health check endpoint request (GET) Test script: const response = await insomnia.send(); expect(response.status).to.equal(200); const body = response.data; expect(body).to.be.a('string'); expect(body.toLowerCase()).to.include('accounts api'); Description of the Insomnia Health Check Test This Insomnia test script performs the following actions:\nSend the Request:\nIt sends the current request and waits for the response. Verify the HTTP Status Code:\nIt asserts that the response status code is 200, confirming a successful operation. Parse and Validate the Response Body:\nIt verifies that the response body is a string. It checks that the string, when converted to lower case, includes the text accounts api. This ensures that the API endpoint correctly returns a string containing the expected accounts api text.\nTest: Credit Account Assign to: Credit an account request Test script: const response = await insomnia.send(); expect(response.status).to.equal(200); const account = JSON.parse(response.data); expect(account).to.have.property('balance').that.is.a('number'); Description of the Insomnia Credit an Account Test This Insomnia test script performs the following actions:\nSend the Request:\nIt sends the current request and waits for the response. Verify the HTTP Status Code:\nIt asserts that the response status code is 200, indicating a successful retrieval. Parse and Validate the Response Body:\nIt parses the response body as JSON. It asserts that the parsed object has a balance property that is a number. This ensures that the API correctly returns an account object with a numerical balance property.\nTest: Debit Account Assign to: Debit an account request Test script: const response = await insomnia.send(); expect(response.status).to.equal(200); const account = JSON.parse(response.data); expect(account).to.have.property('balance').that.is.a('number'); Description of the Insomnia Debit an Account Test This Insomnia test script performs the following actions:\nSend the Request:\nIt sends the current request and waits for the response. Verify the HTTP Status Code:\nIt asserts that the response status code is 200, indicating a successful retrieval. Parse and Validate the Response Body:\nIt parses the response body as JSON. It asserts that the parsed object has a balance property that is a number. This ensures that the API correctly returns an account object with a numerical balance property.\nTest: Get Account By ID Assign to: Retrieve a single account request Test script: const response = await insomnia.send(); expect(response.status).to.equal(200); const account = JSON.parse(response.data); expect(account).to.have.property('account_id').that.is.a('string'); Description of the Get Account by ID Insomnia Test This Insomnia test script performs the following actions:\nSend the Request:\nIt sends the current request and waits for the response. Verify the HTTP Status Code:\nIt asserts that the response status code is 200, indicating a successful retrieval. Parse and Validate the Response Body:\nIt parses the response body as JSON. It asserts that the parsed object has an account_id property that is a string. This ensures that the API correctly returns an account object with a string account_id property.\nRun All the Tests and Push Changes Once you have finished creating all the tests for the endpoints and if you have not already done so, make sure you run the tests and confirm they all pass.\nThen commit and push your changes:\nCommit message: chore: Test suite added with tests for all endpoints Push your changes. Step 4: Extend the Specification with a DELETE Endpoint Now let’s extend the accounts-service.yaml spec by adding a DELETE /accounts/{accountId} operation.\nIncrement the OpenAPI Version Since this is a new feature, update the info.version:\ninfo: title: Accounts API description: This API manages account information and balances. version: 1.1.0 # Updated from 1.0.0, Add DELETE endpoint contact: email: stephen.brown@konghq.com Commit and Push:\nCommit message: chore: increment API version to 1.1.0 for new DELETE endpoint Push your changes. Add the DELETE Operation Extend the /accounts/{accountId} path:\n/accounts/{accountId}: get: # Existing GET operation delete: tags: - accounts operationId: deleteAccount summary: Delete an account description: Permanently removes the specified account and all associated data. This operation cannot be undone. parameters: - name: accountId in: path required: true description: The UUID of the account to delete schema: type: string format: uuid responses: '204': description: Account successfully deleted (no content returned) '404': description: Account not found content: application/json: schema: $ref: '#/components/schemas/ErrorResponse' '500': description: Internal server error content: application/json: schema: $ref: '#/components/schemas/ErrorResponse' Commit and Push:\nCommit message: feat: add DELETE /accounts/{accountId} endpoint Push your changes. Step 5: Manually Create a Delete Request and Test Since this request did not exist during initial collection generation, manually add it now as this will give us experience of manually creating requests as well as auto generating them.\nIn the Collections tab\nCreate a new HTTP request named Delete an account. Path: {{ _.base_url }}/accounts/{{ _.accountId }}\nMethod: DELETE\nAdd a pre-request script copied from the Credit an account After-response script\nAdd an after-response script to unset the accountId:\ninsomnia.environment.unset(\"accountId\") Note: This request will not work at the moment as the underlying implementation does not yet support the delete an account endpoint.\nCreate a Test for DELETE Assign to: Delete an account request Test script: const response = await insomnia.send(); expect(response.status).to.equal(204); expect(response.data).to.satisfy((body) =\u003e body === '' || body === null); Note: This test will not pass at the moment as the underlying implementation does not yet support the delete an account endpoint.\nCommit and Push:\nCommit message: feat: add request and test for DELETE /accounts/{accountId} Push your changes. After committing and pushing:\nCreate a pull request from your feature/add-test-suites-and-delete-endpoint branch into main. Once reviewed, merge your branch to keep the main branch up-to-date with your completed work. Step 6: Versioning Best Practices When managing API specifications:\nChange Type Version Change Example Breaking change Major (1.0.0 → 2.0.0) Removing fields, changing behaviour New features Minor (1.0.0 → 1.1.0) Adding endpoints, fields Bug fixes Patch (1.0.0 → 1.0.1) Correcting typos, examples Maintaining clear versioning communicates the impact of changes to consumers.\nSummary You have now:\nCreated and structured a reusable Test Suite Extended the specification with a DELETE operation Practiced semantic versioning principles Manually created and tested a new request Committed and pushed your work properly Next: In Module 5: Custom Linting, we will enforce API standards by adding custom Spectral linting rules, and deal with removing the DELETE operation to maintain compliance!",
    "description": "In this module, we move beyond scripting and focus on structured, reusable Test Suites in Insomnia, while also extending our specification with a new DELETE operation.\nWith your API specification complete and your collections generated, it’s time to ensure everything works reliably, not just manually, but automatically.\nIn this module, you will:\nUnderstand how Test Suites improve API quality Create automated tests linked to your requests Extend the API by adding a DELETE operation Practice versioning and proper Git commit hygiene Commit and push your testing and spec changes Prerequisites If you are starting the course from this module and have not completed the previous steps, you can import the Insomnia metadata to bring you up to date.",
    "tags": [],
    "title": "04 - Creating Test Suites and Extending the Specification",
    "uri": "/04-testing/index.html"
  },
  {
    "breadcrumb": "APIOps with Insomnia",
    "content": "In this module, we introduce the concept of extending and customising Spectral linting in Insomnia. Many organisations define internal API design standards that build on top of OpenAPI. Insomnia allows you to enforce these standards through custom rules using Spectral — a powerful and flexible linter for structured JSON/YAML documents.\nWe’ll walk through the following:\nWhat Spectral is and how it works in Insomnia How to override, extend, or remove linting rules Creating a .spectral.yaml configuration Enforcing internal standards (such as disallowing DELETE endpoints) Using Git and semantic versioning best practices to manage these changes Step 1: Understanding Spectral Linting Spectral is a rules engine built specifically for OpenAPI, JSON Schema, and AsyncAPI specifications. It scans your spec and flags issues related to style, structure, consistency, or breaking changes.\nBy default, Insomnia includes a base Spectral ruleset for OpenAPI. But this is just a starting point — you can add, override, or remove rules to enforce your organisation’s standards.\nUseful link\nInsomnia: Custom Linting Guide\nStep 2: Creating a Feature Branch Before making any changes to our linting rules, let’s create a dedicated feature branch:\nIn Insomnia, click on the branch name in the Git panel (lower left) Create a new branch named feature/custom-spectral-rules Click “Create” to switch to the new branch Step 3: Prepare the Specification File As we are removing functionality, this may be considered a breaking change. Follow semantic versioning principles.\nIncrement the version from 1.1.0 to 2.0.0 in your spec’s info.version field Stage, commit and push the changes Examples of Custom Spectral Rules Let’s look at a few scenarios: (Do not add these rules to you project, they are just generic examples)\nAdding a Rule Enforce descriptions on all parameters:\nrules: parameter-description: description: \"All parameters must have a description\" severity: error given: \"$.paths[*][*].parameters[*]\" then: field: description function: truthy Replacing a Rule Override the default rule for operation IDs to require a specific naming pattern:\nrules: operation-operationId: description: \"Use kebab-case for operation IDs\" severity: error given: \"$.paths[*][*]\" then: field: operationId function: pattern functionOptions: match: \"^[a-z0-9]+(-[a-z0-9]+)*$\" Removing a Rule To disable a built-in rule entirely:\nextends: spectral:oas rules: info-contact: off Step 4: Enabling Custom Rules in Insomnia To apply your own ruleset, you need to create a .spectral.yaml file in the root of your Git repository. This file will contain your custom rules, and Insomnia will automatically detect it and use it to lint your specification. In the following sections, we’ll walk through exactly how to do this.\nDisallowing DELETE Endpoints Let’s say your internal API Standards Committee has introduced a policy against destructive operations on core resources — including DELETE /accounts/{accountId}.\nWe’ll now walk through enforcing this rule using Spectral.\nCreate a Custom Rule Make sure you have your accounts-service code cloned out locally, and ensure you are in the correct branch.\nClone the repo locally if you have not done so already\nSwitch to you feature branch feature/custom-spectral-rules for custom linting\nCreate .spectral.yaml with the following contents in the root of the repository:\nNote: you can’t add the .spectral.yaml file from inside Insomnia, you will have to add it via another editor\nextends: spectral:oas rules: no-delete-accounts: description: DELETE operations on accounts are not permitted severity: error given: \"$.paths[*].delete\" then: function: falsy This rule flags any path that defines a delete method.\n[accounts-service-sb]$ cat .spectral.yaml extends: spectral:oas rules: no-delete-accounts: description: DELETE operations on accounts are not permitted severity: error given: \"$.paths[*].delete\" then: function: falsy Stage, commit and push your changes\nCommit Your Linting Rules After creating the .spectral.yaml file:\nOpen the Git panel Make sure you are in the feature/custom-spectral-rules branch Pull the new changes into Insomnia’s copy of the repository Step 5: Validate in Insomnia Open your design document in Insomnia. You should now see a new linting error indicating that the DELETE /accounts/{accountId} operation violates your organisation’s standards.\nTake a moment to observe how Insomnia highlights the rule failure directly in the UI, with the custom error message.\nStep 6: Fix the Linting Issue To become compliant again:\nRemove the Delete Account from the Test tab Remove the Delete an account request from Collection tab Remove the delete operation from the /accounts/{accountId} path in the OpenAPI specification file Confirm the linting error disappears in Insomnia Step 7: Commit the Change with Context As we are removing functionality, this may be considered a breaking change. Follow semantic versioning principles.\nCommit using Insomnia Git: feat!: remove DELETE /accounts/{accountId} to meet API compliance\nThe ! in the commit message indicates a breaking change\nPush to your remote branch\nStep 8: Create a Pull Request Once you’ve fixed all linting issues and properly versioned your changes:\nGo to your Git provider’s interface Create a pull request from your feature/custom-spectral-rules branch to the main branch Include context about the API standards being enforced and why the version number was incremented And then merge the PR into the main branch Summary In this module, you learned how to:\nUnderstand and modify the Spectral ruleset used by Insomnia Enforce organisation specific standards through a .spectral.yaml file Identify and resolve rule violations inside the Insomnia UI Manage changes using Git and semantic versioning best practices Share these API standards with your team through version control What’s Next? In the next module, we’ll expand beyond manual tooling and show how to integrate API spec validation into a CI/CD pipeline using the Inso CLI.\nYou’ll learn to:\nRun linting and tests from the command line Validate specs as part of GitHub Actions or Jenkins Prevent invalid changes from being merged Continue to: Module 6: CI/CD Testing",
    "description": "In this module, we introduce the concept of extending and customising Spectral linting in Insomnia. Many organisations define internal API design standards that build on top of OpenAPI. Insomnia allows you to enforce these standards through custom rules using Spectral — a powerful and flexible linter for structured JSON/YAML documents.\nWe’ll walk through the following:\nWhat Spectral is and how it works in Insomnia How to override, extend, or remove linting rules Creating a .spectral.yaml configuration Enforcing internal standards (such as disallowing DELETE endpoints) Using Git and semantic versioning best practices to manage these changes Step 1: Understanding Spectral Linting Spectral is a rules engine built specifically for OpenAPI, JSON Schema, and AsyncAPI specifications. It scans your spec and flags issues related to style, structure, consistency, or breaking changes.",
    "tags": [],
    "title": "05 - Custom Linting with Spectral in Insomnia",
    "uri": "/05-custom-linting/index.html"
  },
  {
    "breadcrumb": "APIOps with Insomnia",
    "content": "In this module, we introduce the Inso CLI — the command-line companion to the Insomnia desktop application. Inso CLI is designed for use in terminal workflows and automation pipelines, bringing the power of Insomnia into your CI/CD systems.\nOfficial docs: Inso CLI Introduction\nStep 1: Understanding Inso CLI Inso CLI is built on Node.js and uses the same core libraries as the Insomnia app. It allows you to:\nRun linting against your OpenAPI spec Execute unit tests defined in Insomnia Export and execute collections Integrate seamlessly into CI/CD pipelines Its primary use case is to enforce API quality and consistency at key stages in the software delivery lifecycle — not just on a developer’s machine, but in the merge and release process itself.\nStep 2: Understanding the CI/CD Benefits While Insomnia’s desktop app ensures quality during local development, organisations often need to guarantee that central standards are applied across all environments. This includes:\nEnforcing consistent API structure and design Preventing non-compliant specs from being merged Ensuring functionality through test coverage Inso CLI supports these goals by making automated validation a natural part of your pipeline.\nA simple CI workflow might look like this:\n1. Checkout branch 2. Setup Node.js and install Inso 3. Run linting with `inso lint spec` 4. Run unit tests with `inso run test` Note: If your organisation supports GitHub Actions, you can use the Setup Inso GitHub Action. Inso-GitHub-Action-Docs Inso-GitHub-Action\nStep 3: Core Commands for This Module We’ll focus on two key Inso CLI commands:\ninso lint spec Lints your OpenAPI specification using Spectral.\ninso run test Executes unit tests created in Insomnia.\nFull command reference available here: Inso CLI Command Reference\nStep 4: Using inso lint spec This command checks your OpenAPI document against Spectral rules.\nSyntax inso lint spec [identifier] You’ll be prompted to select the specification if no identifier is provided.\nOptions Option Description --workingDir / -w Specify a working directory to locate your Insomnia spec file or export Example for our Accounts API # Get the ID of the specification and store in a variable INSO_SPEC_ID=$(awk '/spc_/{print $2}' api/accounts-service.yaml) # Lint the specification inso lint spec -w api/accounts-service.yaml $INSO_SPEC_ID Expected Output No linting errors or warnings. This ensures your spec meets both default and custom Spectral standards (see Module 7).\nStep 5: Using inso run test This command executes unit tests written inside Insomnia.\nCommand Syntax inso run test [identifier] You can target either a test suite or document, and optionally filter by test name.\nCommon Options Option Alias Description --env -e Environment name or ID --testNamePattern -t Regex to run specific tests --reporter -r Output format: spec, list, dot, min, progress -bail -b Exit after the first failure --keepFile Keep generated test file (debugging) Run a Single Test Firstly just run one test by specifying it name:\nINSO_SPEC_ID=$(awk '/spc_/{print $2}' api/accounts-service.yaml) inso run test -w api/accounts-service.yaml $INSO_SPEC_ID --env \"OpenAPI env localhost:8081\" --testNamePattern \"Create New Account\" \"Accounts Test S uite\" Expected Output for inso run test Accounts Test Suite ✓ Create New Account (249ms) 1 passing (252ms) Run All Tests Now run all the tests\nINSO_SPEC_ID=$(awk '/spc_/{print $2}' api/accounts-service.yaml) inso run test -w api/accounts-service.yaml $INSO_SPEC_ID --env \"OpenAPI env localhost:8081\" \"Accounts Test Suite\" Expected Output for targeted inso run test Accounts Test Suite ✓ Create New Account (269ms) ✓ List All Accounts ✓ Health Check ✓ Credit Account ✓ Debit Account ✓ Get Account By ID 6 passing (355ms) Step 6: Creating a CI Configuration File Your organisation may use a different CI/CD system than GitHub Actions — for example, GitLab CI, Jenkins, or Azure Pipelines. The example below provides a GitHub Actions workflow that can easily be adapted to fit other pipeline technologies or formats.\nThis configuration demonstrates how to automate validation of your OpenAPI specification and run your Insomnia test suite during pull requests.\nExample: GitHub Actions – .github/workflows/api-validation.yml name: API Validation on: pull_request: paths: - 'api/**' - '.spectral.yaml' jobs: validate: runs-on: ubuntu-latest steps: - uses: actions/checkout@v3 - name: Setup Inso CLI uses: kong/setup-inso@v1 with: inso-version: 7.x - name: Lint API Specification run: inso lint spec - name: Run API Tests run: inso run test \"Accounts Test Suite\" --env \"OpenAPI env localhost:8081\" This workflow:\nRuns automatically on pull requests that modify the API spec or .spectral.yaml file Installs and configures the Inso CLI Lints the OpenAPI spec using Spectral Executes your Insomnia test suite (Accounts Test Suite) against the specified environment Feel free to replace or extend these steps depending on how your team manages environments, branches, or naming conventions in your pipelines.\nNote on Exports If needed, the raw OpenAPI specification can be extracted from the design document using the Inso CLI export command.\nTo output the specification to stdout — without any Insomnia-specific metadata — run:\nINSO_SPEC_ID=$(awk '/spc_/{print $2}' api/accounts-service.yaml) inso export spec -w ./api/accounts-service.yaml $INSO_SPEC_ID Alternatively, you can export directly to a file:\nINSO_SPEC_ID=$(awk '/spc_/{print $2}' api/accounts-service.yaml) inso export spec -w ./api/accounts-service.yaml $INSO_SPEC_ID -o /tmp/accounts-service.yaml This is especially useful when working in CI/CD pipelines or when passing the clean OpenAPI document to other tools.\nSummary In this module, we:\nIntroduced Inso CLI as the automation tool for Insomnia Learned how to lint OpenAPI specs in CI/CD pipelines Learned how to run unit tests for the Accounts API from the terminal Saw an example CI configuration file to automate API validation By using Inso CLI in your pipelines, you ensure your APIs remain compliant and functional throughout the development lifecycle — not just at the developer’s desk.\nWhat’s Next? In the next module, we’ll look at how to deploy and use mock servers, allowing teams to prototype and test against your APIs even before the backend is implemented.\nContinue to: Module 7: Mocking",
    "description": "In this module, we introduce the Inso CLI — the command-line companion to the Insomnia desktop application. Inso CLI is designed for use in terminal workflows and automation pipelines, bringing the power of Insomnia into your CI/CD systems.\nOfficial docs: Inso CLI Introduction\nStep 1: Understanding Inso CLI Inso CLI is built on Node.js and uses the same core libraries as the Insomnia app. It allows you to:\nRun linting against your OpenAPI spec Execute unit tests defined in Insomnia Export and execute collections Integrate seamlessly into CI/CD pipelines Its primary use case is to enforce API quality and consistency at key stages in the software delivery lifecycle — not just on a developer’s machine, but in the merge and release process itself.",
    "tags": [],
    "title": "06 - CI/CD Testing with Inso CLI",
    "uri": "/06-cicd-testing/index.html"
  },
  {
    "breadcrumb": "APIOps with Insomnia",
    "content": "In this module, we explore the value of API mocking and demonstrate how to use Insomnia’s self-hosted mocking to support dependent service development — in our case, the transactions-service which relies on the accounts-service.\nMocking is an important capability in modern API design and development. It allows teams to:\nWork in parallel — consumers can develop against a stable interface before the backend is live. Prototype integrations without depending on backend uptime. Validate request/response formats early and often. Insomnia supports two modes of mocking:\nCloud-based mocking — available to any logged-in user. These are hosted by Kong’s infrastructure. Self-hosted mocking — available to enterprise users. These mocks are stored in version control and can be deployed via Docker using Mockbin. For organisations with compliance, security, or offline development needs, self-hosted mocking is recommended.\nDocumentation: Insomnia Mocking\nPrerequisites In this module, you’ll need both the accounts-service and the new transactions-service projects loaded into Insomnia. You will also need to have both codebases cloned locally.\nThe accounts-service is required, so we can generate the mock server using live requests in Insomnia. This means the accounts-service must be checked out locally, and its implementation must be running, so it can respond to requests from Insomnia. These live responses will be captured and used to populate the mock.\nOnce the mock is fully configured and committed, we will shut down the running accounts-service and begin development of the transactions-service against the mock instead.\nThe steps below will guide you through setting everything up correctly:\nPrerequisite Step 1: Create Your Repository from the Template Begin by locating the template repository at:\n[https://github.com/kongHQ-CX/transactions-service.git]\nNote: https://github.com/konghq-cx is the address for the public version of this repository, if your company uses an enterprise git offering then this address will be updated in the course notes.\nCreate Your Own Repository Open the template repository in your browser.\nClick “Use this template” or “Generate from template” (the wording may vary depending on your GitHub Enterprise setup).\nName your new repository using the convention of appending your initials:\ntransactions-service-\u003cyour-initials\u003e For example: transactions-service-sb if your initials are SB.\nComplete the repository creation process.\nClone the Repository Locally Once your repository is created, clone it to your local machine:\ngit clone https://github.com/konghq-cx/transactions-service-\u003cyour-initials\u003e.git cd transactions-service-\u003cyour-initials\u003e Note: https://github.com/konghq-cx is the address for the public version of this repository, if your company uses an enterprise git offering then this address will be updated in the course notes.\nDocker Compose Configuration Inside the repository, you’ll find:\nA working OpenAPI specification file Predefined Insomnia request collections A docker-compose.yaml file to launch supporting services This docker-compose file includes not just the transactions-service itself, but also several supporting components used in the final modules of the workshop:\nservices: transactions-api: image: kongcx/transactions:1.0.0 container_name: transactions ports: - \"8082:8082\" environment: - LOG_LEVEL=info - ACCOUNTS_SERVICE_URL=http://accounts-service-mock:8080/bin/${MOCK_PATH_ID} restart: unless-stopped accounts-service-mock: image: ghcr.io/kong/insomnia-mockbin:v2.0.2 container_name: account-service-mock environment: MOCKBIN_REDIS: \"redis://redis:6379\" MOCKBIN_QUIET: \"false\" MOCKBIN_PORT: \"8080\" MOCKBIN_REDIS_EXPIRE_SECONDS: 1000000000 links: - redis ports: - \"8080:8080\" redis: image: redis vault: image: hashicorp/vault:1.19.2 container_name: vault ports: - \"8200:8200\" environment: VAULT_DEV_ROOT_TOKEN_ID: root VAULT_ADDR: http://0.0.0.0:8200 volumes: - ./vault-init.sh:/vault-init.sh command: \u003e sh -c \"vault server -dev -dev-root-token-id=root -dev-listen-address=0.0.0.0:8200 \u0026 sleep 5 \u0026\u0026 sh /vault-init.sh \u0026\u0026 tail -f /dev/null\" Understanding the Compose Configuration The transactions-api container depends on the accounts service to perform credit and debit operations. Rather than connecting to a live version of accounts-service, we point it to a mock instance running in the container account-service-mock. This mock container uses Kong’s Insomnia Mockbin image, which allows us to simulate API responses during testing. The Mockbin container requires Redis, which is included to store route and response definitions. Lastly, for the Secrets Management module, we include a local instance of HashiCorp Vault to demonstrate external secret integration with Insomnia. Warning: Don’t Start the Containers Yet\nWe’ll hold off on starting the Compose stack for now. The transactions-api service requires a valid value for the MOCK_PATH_ID environment variable, which we haven’t created yet.\nTo generate this ID, we must first create a mock entity in Insomnia. Once that’s done, we’ll return to this Compose file and launch the services with the correct configuration.\nPrerequisite Step 2: Open Insomnia and add the Transactions-Service as a project Open Insomnia v11, and make sure you are signed in with your company email.\nClick the + (plus) button in the Projects panel.\nChoose “Git Sync”.\nSet name for the project e.g. transactions-service-\u003cyour-initials\u003e\nEnter the full repository path:\nkonghq-cx/transactions-service-\u003cyour-initials\u003e Click next\nSelect the repository from the dropdown when it appears.\nIf the repository does not appear you may need to authorise Insomnia to you GitHub organisation If this happens you can click on the Can't find a repository? Configure the App link, which will take you off to GitHub to authorise Insomnia You will see a notification that Insomnia has found an existing Insomnia file and will import it.\nPrerequisite Step 3: Make Sure the accounts-service is Running To generate a working mock of the accounts-service, we need to send real requests to its implementation. Insomnia will capture the live responses and use them to populate the mock routes.\nIf you’ve followed along with the previous modules, your accounts-service project should already contain all the required requests. In this case, you simply need to ensure the implementation is running locally.\nNote: If the service is not running, start it with:\ndocker compose up -d Starting from This Module? If you are jumping in at this point of the workshop (e.g., for a focused demo or standalone practice), follow these steps to get the correct project state:\nClone the insomnia-workshop-exports repository if you haven’t already:\ngit clone https://github.com/konghq-cx/insomnia-workshop-exports.git Open Insomnia and create a new Git Sync project, or open an existing one.\nFrom the Insomnia Project Overview, click Import From File, and navigate to:\n\u003cpath-to-your-clone\u003e/module-exports/module-06/api-spec/module-06-end-state.yaml Note: https://github.com/konghq-cx is the address for the public version of this repository, if your company uses an enterprise git offering then this address will be updated in the course notes.\nThis file represents the state of the accounts-service project at the end of Module 6, including:\nA complete API spec Request collections Test suites This will ensure you have everything needed to proceed with the mocking workflow in this module.\nOnce imported, make sure to start the real accounts-service implementation locally so that Insomnia can interact with the live API and capture accurate responses.\nStep 1: Creating a Mock Server for the Accounts API We’ll now create a mock version of the accounts-service, which will be used by the transactions-service for local development and integration.\nCreating a Feature Branch Before we start working with mock servers, let’s create a dedicated feature branch: Make sure you have the accounts-service project selected in Insomnia, then\nClick on the branch name in the Git panel (lower left) Create a new branch named accounts-service-add-mock-server Click “Create” to switch to the new branch Create the Mock Server In Insomnia in the accounts-service project:\nClick + Create → Mock Server. Set the following details:\nName: accounts-service-mock Filename: accounts-service-mock Folder where the file will be saved in the repository: mocks/ folder Self-hosted mock server URL: http://localhost:8080 Commit Your Mock Server Configuration After creating the mock server:\nOpen the Git panel in Insomnia\nCommit with a message:\nfeat: add mock server configuration Push your changes\nStep 4: Populate the Mock Routes We’ll now use the request collection in the accounts-service to seed the mock routes. For each request:\nRun the request in the Collection tab.\nSelect the Mock tab in the right panel.\nChoose accounts-service-mock.\nClick Create New Mock Route.\nAccept the default route name\nFor methods like HEAD, ensure you manually update the method from GET to HEAD after creating the route.\nFor endpoints with multiple methods sharing the same path (such as /health or /accounts), create the non-GET methods (e.g. HEAD, POST) first. Insomnia defaults new mock routes to the GET method. This default behavior can cause duplicate path conflicts, preventing other methods from being added later if the GET route is created first. To avoid this, always add the GET route last. Always add the GET route last to avoid this conflict.\nRepeat this for:\nHEAD /health GET /health POST /accounts (select POST at the mock request screen) GET /accounts POST /accounts/{accountId}/credit (select POST at the mock request screen) POST /accounts/{accountId}/debit (select POST at the mock request screen) GET /accounts/{accountId} At this point, your mock entity is complete and can be versioned along with the repository.\nCommit Your Mock Routes After adding all routes:\nOpen the Git panel in Insomnia\nCommit with a message:\nfeat: add complete set of mock routes for accounts service Push your changes\nStop the live accounts-service, in the accounts-service repo run:\ndocker compose down Step 5: Creating a Feature Branch for the Transactions-Service Before we copy the mock server into the transactions-service, let’s create a dedicated feature branch: Make sure you have the transactions-service project selected in Insomnia, then\nClick on the branch name in the Git panel (lower left) Create a new branch named transactions-service-add-mock-server Click “Create” to switch to the new branch Step 6: Copy the Mock Server From the accounts-service-\u003cyour-initials\u003e project:\nOpen accounts-service-mock Click the Duplicate button Set the destination to the transactions-service-\u003cyour-initials\u003e project Step 7: Using the Mock in the Transactions API Now let’s consume the mock from another service.\nExtract Required Details Select the accounts-service-mock in the transactions-service project\nOpen the mock route for POST /accounts/{accountId}/credit Click Show URL Copy: The mock hash (e.g. mock_b9b5b297315c47c1964d94b2f79fa8f8) The accountId from the path (696d0848-b30a-4c9e-b2c7-108aeacc8432 in our example) Now use the mock hash value as the value for the MOCK_PATH_ID environment variable when starting docker compose. Run the following now to start the transactions-service and its supporting services:\nMOCK_PATH_ID=\u003cvalue-of-mock-hash\u003e docker compose up -d This starts:\nThe self-hosted mock (Mockbin + Redis) The transactions-api container Note: HashiCorp Vault is also started but not used in this module.\nStep 8: Activate the Mock in Insomnia Back in Insomnia:\nGo to the accounts-service-mock Click the Test button on each route to send data to Mockbin This activates and stores the mock responses inside Mockbin.\nStep 9: Update the Transaction Service Environment In the transactions-service project:\nSelect the Collection tab Edit the OpenAPI env localhost:8081 environment Add a accountId to match the one from the mock URL (e.g., 696d0848-b30a-4c9e-b2c7-108aeacc8432) Now, you can run each request in the collection — all of which will interact with the mock accounts-service!\nCommit Environment Updates After updating the environment:\nOpen the Git panel in Insomnia\nCommit with a message:\nchore: update environment to work with mocked accounts service Push your changes\nStep 7: Merge Your Mock Server Branch Once everything is working correctly:\nOpen the Git panel Make sure all changes are committed and pushed Create a pull request in your Git provider’s interface After review, merge the transactions-service-add-mock-server branch into your main branch Do the same for the accounts-service feature branch accounts-service-add-mock-server Summary In this module, you:\nCreated a self-hosted mock using Insomnia and Mockbin Populated the mock routes from live requests Used Git integration to version control your mock configuration Configured Docker Compose to wire up the mock service Enabled local development of a dependent API without requiring the upstream service to be running This allows teams to work asynchronously, reduce dependencies, and prototype faster — all while staying compliant with your version-controlled design contracts.\nWhat’s Next? In the next module, we’ll cover how Insomnia helps you securely manage sensitive data such as tokens, credentials, and environment variables across teams.\nContinue to: Module 8: Secrets and Secure Collaboration",
    "description": "In this module, we explore the value of API mocking and demonstrate how to use Insomnia’s self-hosted mocking to support dependent service development — in our case, the transactions-service which relies on the accounts-service.\nMocking is an important capability in modern API design and development. It allows teams to:\nWork in parallel — consumers can develop against a stable interface before the backend is live. Prototype integrations without depending on backend uptime. Validate request/response formats early and often. Insomnia supports two modes of mocking:",
    "tags": [],
    "title": "07 - Mocking",
    "uri": "/07-mocking/index.html"
  },
  {
    "breadcrumb": "APIOps with Insomnia",
    "content": "Managing secrets securely is a vital part of working with APIs, especially in teams and across environments. In this module, we’ll explore how Insomnia supports secret management and how you can integrate with enterprise-grade external vaults to securely store and share sensitive data.\nWe will:\nExplore how secret management works in Insomnia Compare local secrets with enterprise external vaults Focus on using HashiCorp Vault (on-premises) with AppRole authentication Walk through a full example using the transactions-service and a locally running HCV instance Official docs:\nInsomnia Secret Management Enterprise Vault Integration Prerequisites In order to complete this module you will need to work on a copy of the transactions-service template GitHub repository. This was set up in the last module. If you are jumping directly into this module without having completed the previous one please follow these steps to set up your copy of the transactions-service.\nCreate Your Repository from the Template Begin by locating the template repository at:\nhttps://your-git-enterprise-repo/konghq-cx/transactions-service.git\n(or for Kong Internal teams its) [https://github.com/kongHQ-CX/transactions-service.git]\nGenerate from Template Open the template repository in your browser.\nClick “Use this template” or “Generate from template” (the wording may vary depending on your GitHub Enterprise setup).\nName your new repository using the convention of appending your initials:\ntransactions-service-\u003cyour-initials\u003e For example: transactions-service-sb if your initials are SB.\nComplete the repository creation process.\nClone the Repository Locally Once your repository is created, clone it to your local machine:\ngit clone https://\u003ccustomer-git-enterprise-repo\u003e/konghq-cx/transactions-service-\u003cyour-initials\u003e.git cd transactions-service-\u003cyour-initials\u003e If you’re running this internally at Kong, use:\ngit clone https://github.com/konghq-cx/transactions-service-\u003cyour-initials\u003e.git cd transactions-service-\u003cyour-initials\u003e Open Insomnia and add the Transactions-Service as a project Open Insomnia v11, and make sure you are signed in with your company email.\nClick the + (plus) button in the Projects panel.\nChoose “Clone from Git Repository”.\nSet name for the project e.g. transactions-service-\u003cyour-initials\u003e\nEnter the full repository path:\nkonghq-cx/transactions-service-\u003cyour-initials\u003e Click next\nSelect the repository from the dropdown when it appears.\nIf the repository does not appear you may need to authorise Insomnia to you GitHub organisation If this happens you can click on the Can't find a repository? Configure the App link, which will take you off to GitHub to authorise Insomnia You will see a notification that Insomnia has found an existing Insomnia specification file and will import it.\nStep 1: Understanding Why Secrets Management Matters Secrets like API keys, tokens, and credentials should never be stored in plaintext or committed to source control. Insomnia provides secure and flexible options to keep sensitive data safe while still enabling teams to collaborate effectively.\nStep 2: Creating a Feature Branch Before we start configuring secrets management, let’s create a dedicated feature branch:\nIn Insomnia, select the transactions-service project and click on the branch name in the Git panel (lower left) Create a new branch named feature/vault-integration Click “Create” to switch to the new branch Step 3: Local Secret Environment Variables (Developer-only) Insomnia supports local secret environments, which allow individuals to store secrets securely and privately.\nFeatures Secrets are stored encrypted on disk Not synced with Git or shared with others Values are masked in the UI Accessed using vault.\u003cvariableName\u003e How to Set One Up Note: We want to focus on enabling secure secret collaboration, which the private vault does not provide therefore the following steps are just for reference.\nTo set up a Private Vault:\nNavigate to Insomnia → Settings → Generate Vault Key and generate your Vault Key. Copy the generated key somewhere safe In your environment settings, create a Private Sub-Environment. Add secret variables, setting the type to Secret. Note: Local secrets cannot be shared — ideal for individual developer use only.\nStep 4: Understanding Enterprise Vault Integration Insomnia Enterprise allows integration with external secret managers, enabling secure collaboration across your organisation.\nSupported Providers HashiCorp Vault (Cloud or On-Prem) AWS Secrets Manager GCP Secret Manager Azure Key Vault This module focuses on HashiCorp Vault (On-Prem) with AppRole authentication. We want to be able to add a secret value to our transactions-service environment, so we can use it as the value for an API key in a request.\nStep 5: Setting Up HashiCorp Vault with AppRole We’ll now walk through how to configure Insomnia to retrieve secrets from an HCV server and use them in requests from the transactions-service.\nStart a Local HCV and transactions-service implementation From your local cloned copy of the transactions-service repository, run the following\ndocker-compose up -d The docker compose file sets up HCV with an API key secret at the following path: secret/transactions-api/api-key\nThen we need to retrieve the role ID and secret ID, so we can use them in Insomnia, there is a helper script to get these credentials in the transactions-service repository:\n./get-vault-creds.sh role_id: 1e90574e-2d87-0bb2-5efb-46692083d872 secret_id: 3256202a-d9d3-b284-e2c8-37dd91911928 Save both values — we’ll need them in Insomnia.\nStep 6: Configure Insomnia to Use HashiCorp Vault Navigate to Insomnia → Settings → Cloud Credentials Click Add Credentials Select HashiCorp Vault Input the following: Credential Name: local-hcv Vault Server: [http://localhost:8200] (or your internal Vault URL) Environment: On-Premises Authentication Method: AppRole Role ID: (your retrieved role-id) Secret ID: (your retrieved secret-id) Save the credential Step 7: Reference the Secret in the Environment In your transactions-service project:\nOpen the Environment Editor\nSwitch to table view\nAdd a new variable called api_key Right click in the value field and select external vault then HashiCorp Vault\nFill in the details as follows:\nField Name Value Credential For Vault Service Provider local-hcv Secret Name transactions-api/api-key KV Secret Engine Version v2 Secret Engine Path secret Secret Key value The live preview should automatically update with the secret value Commit Your Environment Configuration After adding the vault reference:\nOpen the Git panel in Insomnia\nCommit with a message:\nfeat: add HashiCorp Vault integration for API key management Push your changes\nStep 8: Use the Secret in a Request Update a request in the transaction’s collection to use the secret:\nSelect the GET health request Select the Auth tab Choose API Key from the drop-down list Set the key name to X-BanKong-API-Key Set the key value to {{ api_key }} Make a request from the GET health request, and view that the console displays the decoded API key secret You’ll see the value remains masked in the editor but will be correctly injected during request execution. Commit Your Request Updates After updating requests to use vault variables:\nOpen the Git panel in Insomnia\nCommit with a message:\nrefactor: use vault-managed API key in request headers Inspect your commit changes to make sure no sensitive data is shared in source control Push your changes\nStep 11: Final Merge Once everything is working correctly:\nOpen the Git panel Make sure all changes are committed and pushed Create a pull request in your Git provider’s interface After review, merge the feature/vault-integration branch into your main branch Summary In this module, you’ve:\nExplored Insomnia’s built-in secret management features Understood the difference between local secrets and external vaults Configured HashiCorp Vault with AppRole authentication Retrieved and injected secrets securely into requests Used secure secrets in a collaborative environment Committed all changes using Git integration in Insomnia, ensuring no sensitive data is stored in version control This approach ensures sensitive values never appear in plaintext, while still allowing your team to collaborate using shared specs and environments.",
    "description": "Managing secrets securely is a vital part of working with APIs, especially in teams and across environments. In this module, we’ll explore how Insomnia supports secret management and how you can integrate with enterprise-grade external vaults to securely store and share sensitive data.\nWe will:\nExplore how secret management works in Insomnia Compare local secrets with enterprise external vaults Focus on using HashiCorp Vault (on-premises) with AppRole authentication Walk through a full example using the transactions-service and a locally running HCV instance Official docs:",
    "tags": [],
    "title": "08 - Secrets and Secure Collaboration",
    "uri": "/08-secrets-and-secure-collaboration/index.html"
  },
  {
    "breadcrumb": "",
    "content": "Introduction Insomnia is an open source desktop application that simplifies designing, debugging, and testing APIs. Insomnia combines an easy-to-use interface with advanced functionality, like authentication helpers, code generation, and environment variables.\nWorkshop Overview Since that content was first developed, Insomnia has evolved significantly, especially with the release of Insomnia v11, which introduced:\nA new Git-based storage model (no longer relying on a .insomnia directory) Enhanced scripting support (pre-request and post-response) Secure secret handling via local and external enterprise vaults Support for mocking APIs during design and development This workshop focuses heavily on helping enterprise teams adopt modern workflows using Git-backed projects, external vault integrations, custom-linting and secrets from external vaults.\nThe repository currently contains a set of modules, and inside each module, documentation on how it should be run. It is intended to support the development of several onboarding artefacts:\nCollateral for in-person instructor-led workshops Storyboards and exercises for video-based tutorials Self-led labs that can be run independently by teams or individuals Supporting Artefacts This workshop also makes use of two additional repositories that provide working implementations for the API specifications built throughout the modules. These implementations allow us to demonstrate a broader range of Insomnia’s advanced features, including mocking and secret management.\nThe original BanKonG application combined both accounts and transactions into a single, GUI-based app. However, for the purposes of this workshop, we have split the functionality into two separate services: one for accounts and one for transactions, with no GUI.\nThis separation makes it easier to demonstrate developing a dependent API (transactions-service) using mocking when the upstream API (accounts-service) is not available.\nWorkshop Structure and Learning Path Participants will work through a real-world use case to design, debug, and test an API using Insomnia’s full capabilities — both the desktop IDE and Inso CLI.\nParticipants Will Learn How To Set up a Git-backed Insomnia project Design and version a full OpenAPI specification Build and organise request collections Write reusable test suites Implement pre-request and post-request scripting Create and consume mock APIs Configure custom Spectral linting rules Integrate with external vaults like HashiCorp Vault for secrets management Automate testing and linting via CI/CD with Inso CLI Utilise Insomnia mocking to aid API design The Core Use Case Participants will build out a complete API for the accounts-service, including all its key operations (create, list, credit, debit, etc.). As the workshop progresses, they will also explore a second dependent service — the transactions-service — which integrates with the accounts-service.\nThis structure allows us to demonstrate mocking and inter-service collaboration in realistic development workflows.\nServices Used in This Workshop To participate fully in the workshop, participants need access to the following repositories:\naccounts-service\nContains an implementation for the banking Accounts API. This is the primary focus of the workshop. And we will use it to design the specification and demonstrate Insomnias features.\nContainer image: kongcx/accounts-service:1.0.0\ntransactions-service\nA secondary service used to demonstrate mocking and secret-sharing workflows. This service depends on the accounts-service to function.\nContainer image: kongcx/transactions-service:1.0.0\nThese repositories contain ready-to-use Docker setups, Insomnia specs, and example configurations tailored for this workshop.\nThese supporting artefacts must be made available in the customer’s environment. Coordinate with the customer’s account team to ensure that the artefacts are uploaded to the correct locations.\nEnterprise Considerations Many large organisations will not be able to use public GitHub or docker hub, for these situations the repositories can be imported into a customer enterprise GitHub environment and the container images into an approved artefact store.\nWorkshop Structure Each section corresponds to a key module in the learning journey:\nInsomnia Overview Project Setup and Git Integration Building the API Specification Collections and Scripting Creating Test Suites and Extending the Specification Custom Linting with Spectral in Insomnia CI/CD Testing with Inso CLI Mocking Secrets and Secure Collaboration Each one includes objectives, and exercises for that section. Some modules also contain screenshots, YAML configs, or example response data to help guide the learning process.\nOther Supporting Repositories The course is designed to be completed sequentially, from Module 01 through to Module 08, with each module building on the work from the previous one. Module 00 serves as an initial overview of the Insomnia tool itself.\nHowever, we recognise that some users may prefer to focus on specific topics rather than working through the entire sequence. For example, a participant who already feels confident with Insomnia basics, Git integration, API specification design, collections, and testing may wish to dive directly into Module 07: Custom Linting. To support this flexibility, users should be able to start any module by importing the correct project state, so that their Insomnia environment matches the expected starting point for that module.\nTo enable this, we provide a supporting repository containing Insomnia metadata exports for each module.\nMost modules include only the Insomnia v5 OpenAPI specification file, which captures the design document, collections, environments, and tests.\nFor Modules 07 and 08, additional mock metadata files are included to support the mocking workflows covered in those sections.\nStructure of the Insomnia Exports Repository insomnia-workshop-exports ├── accounts-service │ ├── module-02 │ │ └── api-spec │ │ └── module-02-end-state.yaml │ ├── module-03 │ ├── module-04 │ │ └── api-spec │ │ └── module-04-end-state.yaml │ ├── module-05 │ │ └── api-spec │ │ ├── module-05-01-end-state.yaml │ │ └── module-05-02-end-state.yaml │ ├── module-06 │ │ └── api-spec │ │ └── module-06-end-state.yaml │ ├── module-07 │ │ ├── api-spec │ │ │ └── module-07-end-state.yaml │ │ └── mock-spec │ │ └── module-07-mock-end-state.yaml │ └── module-08 └── transactions-service ├── module-07 │ ├── api-spec │ │ └── module-07-end-state.yaml │ └── mock-spec │ └── module-07-mock-end-state.yaml └── module-08 └── api-spec └── module-08-end-state.yaml Where there are two end-state files for a single module, it indicates that the module contains multiple parts, and each part has its own corresponding final state export.\nThis export structure ensures that users can pick up the workshop at any point while maintaining a consistent and correct project setup in Insomnia.\nLike with the other supporting artefact this repository will also need to be made available in the customer’s environment, the appropriate steps should be taken to make these supporting artefacts are uploaded to the correct places.\nList of Supporting Artefacts and locations In order for a customer’s employees to undertake the course, the following artefacts should be uploaded to the customer’s environment (e.g., GitHub Enterprise, Nexus).\nThis repo or access Kong Academy to obtain the course materials accounts-service. Set this up as a GitHub or GitLab repository template. (If BitBucket clone and create new repository from clone) transactions-service. Set this up as a GitHub or GitLab repository template. (If BitBucket clone and create new repository from clone) accounts-service docker image docker.io/kongcx/accounts-service:1.0.0 transactions-service docker image docker.io/kongcx/transactions-service:1.0.0 redis docker image docker.io/library/redis:7.4.3 insomnia-mockbin docker image ghcr.io/kong/insomnia-mockbin:v2.0.2 HashiCorp-Vault docker image docker.io/hashicorp/vault:1.19.3 Export repository - Used to allow participants to jump into any module and load the end state from the last module Where to Start The process should begin with Module 0: Insomnia Overview, and teams should progress through each module in order. By the end, they will have developed a fully defined and testable API workflow — ready to integrate into their organisation’s APIOps pipeline. The content has also been structured to support flexibility. Teams can choose to start with a specific module and import all previous improvements up to that point. This allows them to dive directly into a topic of interest without having to complete every preceding module first.",
    "description": "Introduction Insomnia is an open source desktop application that simplifies designing, debugging, and testing APIs. Insomnia combines an easy-to-use interface with advanced functionality, like authentication helpers, code generation, and environment variables.\nWorkshop Overview Since that content was first developed, Insomnia has evolved significantly, especially with the release of Insomnia v11, which introduced:\nA new Git-based storage model (no longer relying on a .insomnia directory) Enhanced scripting support (pre-request and post-response) Secure secret handling via local and external enterprise vaults Support for mocking APIs during design and development This workshop focuses heavily on helping enterprise teams adopt modern workflows using Git-backed projects, external vault integrations, custom-linting and secrets from external vaults.",
    "tags": [],
    "title": "APIOps with Insomnia",
    "uri": "/index.html"
  },
  {
    "breadcrumb": "APIOps with Insomnia",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Categories",
    "uri": "/categories/index.html"
  },
  {
    "breadcrumb": "APIOps with Insomnia",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tags",
    "uri": "/tags/index.html"
  }
]
